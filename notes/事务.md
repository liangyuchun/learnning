## 事务

* [什么是事务](#什么是事务)
* [事务四大特性](#事务四大特性)
* [如何保持原子性](#如何保持原子性)
* [如何保持隔离性](#如何保持隔离性)
* [事务的隔离级别](#事务的隔离级别)
* [事务并发MVCC](#事务并发MVCC)
* [如何保持持久性](#如何保持持久性)

### 什么是事务

事务作为关系型数据库的核心组成，它将数据有条理的保存在存储介质中，将数据结构化的形态呈现给用户。
支持数据的增删改查，并在过程中，保证数据的正确可靠。

### 事务四大特性

原子性(Atomicity)：事务要么全部完成，要么全部取消。如果事务崩溃，状态回到事务之前。
一致性(Consistency)：事务执行后，数据库状态和其他业务规则保持一致，只有合法的数据才能写入数据库。
隔离性(Isolation)：事务和事务之间是隔离开的，互不影响. 一个事务看不到另一个事务正在操作的数据。
持久性(Durability)：一旦事务提交，不管发生什么，数据保存在数据库中。

### 如何保持原子性

在开启事务和提交事务之间的数据操作当成一个原子单元，统一提交事务，统一失败回滚。

### 如何保持隔离性

原子性的问题解决了，但如果有另外的事务在同时修改数据A呢？
此时要引入数据的隔离机制，确保同时只能有一个事务在修改A，一个修改完了，另一个才能修改，这需要对数据增加互斥锁。
在事务中更新某条数据获得的互斥锁，只有在事务提交或失败后才会释放。在此之前，其他事务只能读，不能写这条数据。这是事务隔离性的关键。

### 事务的隔离级别

- 串行化(Serializable，SQLite默认模式)：最高级别的隔离级别，串行化执行，100%隔离。
- 可重复读(Repeatable read，MySQL默认模式)：如果一个事务成功执行并添加了新的数据(事务提交)，这些数据对其他正在执行的事务是可见的。
但是事务成功修改了一条数据，修改的结果对正在运行的事务是不可见的。这叫幻读。所以，事务之间只在新数据方面突破了隔离，对已存在的数据仍旧隔离。
- 读取已提交(Read committed，Oracle、PostgreSQL、SQL Server默认模式)：能读取到其他事务提交成功的数据，修改结果对正在运行的事务是可见的。
如果事务A读取了数据D，数据D被事务B修改并提交，事务A再次读取了数据D已变化，这叫不可重复读。
- 读取未提交(Read uncommitted)：最低级别的隔离，能读取其他事务未提交的数据。如果事务A读取了数据D，然后数据D被事务B修改（但并未提交，事务B仍在运行中），
事务A再次读取数据D时，数据修改是可见的。如果事务B回滚，那么事务A第二次读取的数据D是无意义的，因为那是事务B所做的从未发生的修改（已经回滚了嘛）。这叫脏读。

### 事务并发MVCC

所谓的MVCC（Multi-Version Concurrency Control 多版本并发控制）指的就是在使用读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子事务之间并发执行，从而提升系统性能。
这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，数据的可重复读其实就是ReadView的重复使用。

### 如何保持持久性

如果事务提交后，事务的数据还没有真正落到磁盘上，此时数据库崩溃，事务对应的数据会不会丢？
事务会保证数据不会丢失，当数据库因为不可抗拒的原因崩溃后重启，它会保证：
- 成功提交的事务，数据会保存到磁盘中，查询 Redo log,进行写盘
- 未提交的事务，相应的数据会回滚，查询 Undo log，进行回滚

### 数据落盘



