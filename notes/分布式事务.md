## 分布式事务

* [分布式事务](#分布式事务)
* [分布式事务方案](#分布式事务方案)
  * [2PC](#2PC)
  * [3PC](#3PC)
  * [TCC](#TCC)
* [XA协议](#XA协议)
* [SEATA](#SEATA)
  * [AT模式](#AT模式)
  * [XA模式](#XA模式)
* [总结](#总结)

### 分布式事务

事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同节点之上，多个数据源的事务处理机制，
分布式事务需要保证这些操作的一致性。

### 分布式事务方案

把多个服务的访问都能纳入到同一个事务当中

#### 2PC

两阶段提交是把整个事务分为两个阶段： prepare 阶段和 commit 阶段。
以常见电商系统为例，分布式系统中有订单、账户和库存三个服务，如下图：
![](pics/2pc.jpeg)

第一阶段，事务协调者向事务参与者发送 prepare 请求，事务参与者收到请求后，如果本地可以提交事务，回复 yes，否则回复 no。

第二阶段，如果所有事务参与者都回复了 yes，事务协调者向所有事务参与者发送 commit 请求，否则发送 rollback 请求。

存在问题：

- 同步阻塞：本地事务在prepare阶段锁定资源，其他事务要修改资源就要等前面事务完成
- 数据不一致：如果prepare阶段成功了，第二阶段TM向RM发送命令时失败，就会导致数据不一致
- TM单节点故障：如果prepare阶段成功后，在第二阶段发送命令之前宕机，所有服务的当前事务资源就会一直处于等待状态

#### 3PC

为解决两阶段提交的问题，三阶段提交做了改变：

- 协调者和参与者都引入了超时机制
- 第一阶段prepare阶段分成两步，canCommi 和 preCommit。

如下图：
![](pics/3pc.jpeg)

存在问题：
多了一次网络通信，性能上变得更差；引入preCommit后，协调者在发送commit之前再次检测各个事务参与者状态，保证他们的状态是一致的，
但也存在问题，如果第三阶段协调者发出rollback命令，有参与者没有收到，那没有收到的节点会在超时后自动提交，造成数据不一致。

#### TCC

TCC 分别指 Try、Confirm、Cancel ，一个业务操作要对应的写这三个方法。
以下单扣库存为例，Try 阶段去占库存，Confirm 阶段则实际扣库存，如果库存扣减失败 Cancel 阶段进行回滚，释放库存。

存在问题：
原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。
还要考虑到网络波动等原因，为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。

### XA协议

XA 协议是由 X/Open 组织提出的分布式事务处理规范，主要定义了事务管理器 TM 和局部资源管理器 RM 之间的接口。
目前主流的数据库，比如 oracle、DB2、MySql 都是支持 XA 协议的。

xa 事务的语法如下：

三阶段的第一阶段：开启 xa 事务，这里 xid 为全局事务 id：
XA {START|BEGIN} xid [JOIN|RESUME]
结束 xa 事务：XA END xid [SUSPEND [FOR MIGRATE]]

三阶段的第二阶段，即 prepare：
XA PREPARE xid

三阶段的第三阶段，即 commit/rollback：
XA COMMIT xid [ONE PHASE]XA ROLLBACK xid
查看处于 PREPARE 阶段的所有事务：
XA RECOVER XA RECOVER [CONVERT XID]

### SEATA

Seata 是一款开源的分布式事务解决方案，提供了 AT、TCC、SAGA 和 XA 等事务模式。
参与角色TC (Transaction Coordinator) - 事务协调者、TM (Transaction Manager) - 事务管理器、RM (Resource Manager) - 资源管理器

### AT模式

seata的at模式是两阶段提交协议的演变.AT模式。
第一阶段 业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
第二阶段 提交异步化，非常快速地完成/回滚通过一阶段的回滚日志进行反向补偿。

工作机制示例：

业务表：product


| Field | Type         | Key |
| ------- | -------------- | ----- |
| id    | bigint(20)   | PRI |
| name  | varchar(100) |     |
| since | varchar(100) |     |

AT 分支事务的业务逻辑：

```
update product set name = 'GTS' where name = 'TXC';
```

- 一阶段

  1. 解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = 'TXC'）等相关的信息。
  2. 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。

  ```
  select id, name, since from product where name = 'TXC';
  ```

  得到前镜像：
  id	name	since
  1	    TXC	    2014

  3. 执行业务 SQL：更新这条记录的 name 为 'GTS'。
  4. 查询后镜像：根据前镜像的结果，通过 主键 定位数据。

  ```
  select id, name, since from product where id = 1`;
  ```

  得到后镜像：
  id	name	since
  1	GTS	    2014

  5. 插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。
  6. 提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。
  7. 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。
  8. 将本地事务提交的结果上报给 TC。
- 二阶段-回滚

  1. 收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。
  2. 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。
  3. 数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。
  4. 根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：

  ```
  update product set name = 'TXC' where id = 1;
  ```

  5. 提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。
- 二阶段-提交

  1. 收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。
  2. 异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。

#### XA模式

seata的xa模式对传统的三阶段提交做了优化，改成了两阶段提交.XA模式。
第一阶段首执行 XA 开启、执行业务sql、XA 结束三个步骤，之后直接执行 XA prepare。
第二阶段执行 XA commit/rollback。

如下图：
![](pics/SEATA-XA.png)

对代码无侵入；分布式强一致性的解决方案，但性能低；
依赖数据库驱动程序，不同的厂商、不同版本的数据库驱动有不同的实现机制，会有兼容性问题，如：创建数据源代理实现的方式Oracle兼容性不是很好。

### 总结

不管我们选哪一种方案，在项目中应用都要谨慎使用，除特定的数据强一致性场景外，能不用尽量不用，
因为无论它们性能如何优越，一旦项目套上分布式事务，整体效率会几倍的下降，在高并发场景下弊端尤为明显。
